var MalinkyAjaxPaging = (function($) {

    //Variables, some from wp_localize_script().
    var mapInfiniteScrollBuffer             = parseInt(malinky_ajax_paging_options.infinite_scroll_buffer),
        mapLoadingTimer                     = '',
        mapLoadingMorePostsText             = malinky_ajax_paging_options.loading_more_posts_text,
        mapLoadMoreButtonText               = malinky_ajax_paging_options.load_more_button_text,
        mapPaginationClass                  = malinky_ajax_paging_options.pagination_wrapper,
        mapPaginationClassPixelsToDocBottom = $(document).height() - $(mapPaginationClass).offset().top,
        mapPagingType                       = malinky_ajax_paging_options.paging_type,
        mapPostsWrapperClass                = malinky_ajax_paging_options.posts_wrapper,
        mapPostClass                        = malinky_ajax_paging_options.post_wrapper,
        mapMaxNumPages                      = parseInt(malinky_ajax_paging_options.max_num_pages),
        mapNextPageNumber                   = parseInt(malinky_ajax_paging_options.next_page_number),
        mapNextPageSelector                 = malinky_ajax_paging_options.next_page_selector,
        mapNextPageUrl                      = $(malinky_ajax_paging_options.next_page_selector).attr('href') || malinky_ajax_paging_options.next_page_url;        


    /**
     * Initialize.
     * Add new pagination and loading div.
     * These are added after the last mapPaginationClass as some theme developers don't wrap pagination
     * but use same class for all elements of it.
     */
    var init = function() {

        if (mapPagingType == 'load-more') {

            $(mapPaginationClass).last().after('<a href="' + mapNextPageUrl + '" class="malinky-ajax-paging-button button full-width">' + mapLoadMoreButtonText + '</a>');
            $(mapPaginationClass).last().before('<div class="malinky-ajax-paging-loading"></div>');
            $(mapPaginationClass).remove();
            /**
             * Attach a click event handler to the new pagination button.
             * No longer use delegate event as this click event is added after the new pagination button is added to the dom.
             */
            $('.malinky-ajax-paging-button').click(function(event) {
                event.preventDefault();
                //Delay loading text and div.
                mapLoadingTimer = setTimeout(mapLoading, 750);
                //Load more posts.
                mapLoadPosts();
                /**
                 * Debug timer. Remove mapLoadPosts call and use setTimeout instead.
                 * setTimeout(mapLoadPosts, 3000);
                 */
            }); 

        } else if (mapPagingType == 'infinite-scroll') {

            $(mapPaginationClass).last().before('<div class="malinky-ajax-paging-loading"></div>');
            $(mapPaginationClass).remove();
            window.addEventListener('scroll', mapInfiniteScroll);

        } else if (mapPagingType == 'pagination') {

            $(mapPaginationClass).last().before('<div class="malinky-ajax-paging-loading"></div>');
            /**
             * Attach a click event handler to the pagination links.
             * The pagination class is reloaded after a page change to update the page numbers.
             * Therefore a delegated event is used to bind to the newly added pagination class.
             * This is attached to the document as it's the only item we can be sure to be there on first page load.
             */
            $(document).on('click', mapPaginationClass, function(event) {
                event.preventDefault();
                //Delay loading text and div.
                mapLoadingTimer = setTimeout(mapLoading, 750);
                //Get the url of the clicked page.
                mapNextPageUrl = event.target.href;
                //Load more posts.
                mapLoadPosts();
                /**
                 * Debug timer. Remove mapLoadPosts call and use setTimeout instead.
                 * setTimeout(mapLoadPosts, 3000);
                 */
            });
            /**
             * Attach popstate event listener which is triggered on the back button.
             * The url generated by the browser back/forward button is saved in mapNextPageUrl and mapLoadPosts called.
             */
            window.addEventListener('popstate', function(event) {
                mapNextPageUrl = document.URL;
                mapLoadPosts();
            });

        }
     
    };


    /**
     * Load new posts and append to exists content.
     * The response inserts new posts after the last displayed post that uses the mapPostClass.
     * mapPostsWrapperClass is used to ensure the correct div is targeted.
     */
    var mapLoadPosts = function () {
        $.ajax({
                type:       'GET',
                url:        mapNextPageUrl,
                dataType:   'html',
                success:    function(response) {
                                //Parse HTML first.
                                var mapResponse = $.parseHTML(response);
                                //Find the actual posts from the full html response using mapPostClass.
                                var $mapLoadedPosts = $(mapResponse).find(mapPostClass);
                                //jQuery object of the last currently displayed post.
                                var $mapInsertPoint = $(mapPostsWrapperClass + ' ' + mapPostClass).last();
                                
                                if (mapPagingType == 'load-more') {
                                    //Insert the posts after the last currently displayed post.
                                    $mapInsertPoint.after($mapLoadedPosts);
                                    //Increment page number.
                                    mapNextPageNumber++;
                                    //Check we're not on the last page and all posts have been loaded.
                                    if (mapNextPageNumber > mapMaxNumPages) {
                                        $('.malinky-ajax-paging-button').remove();
                                    }
                                    //Update next page url.
                                    mapNextPageUrl = mapNextPageUrl.replace(/\/page\/[0-9]*/, '/page/'+ mapNextPageNumber);
                                }

                                if (mapPagingType == 'infinite-scroll') {
                                    //Insert the posts after the last currently displayed post.
                                    $mapInsertPoint.after($mapLoadedPosts);
                                    //Increment page number.
                                    mapNextPageNumber++;
                                    //Check we're not on the last page and all posts have been loaded.
                                    if (mapNextPageNumber > mapMaxNumPages) {
                                        window.removeEventListener('scroll', mapInfiniteScroll);
                                    }
                                    //Update next page url.
                                    mapNextPageUrl = mapNextPageUrl.replace(/\/page\/[0-9]*/, '/page/'+ mapNextPageNumber);
                                }                                

                                if (mapPagingType == 'pagination') {
                                    //Save the existing posts to be removed after insertion of the new posts after them.
                                    var $mapExistingPosts = $(mapPostClass);
                                    //Insert the posts after the last currently displayed post.
                                    $mapInsertPoint.after($mapLoadedPosts);                                    
                                    //Remove previously existing posts.
                                    $mapExistingPosts.remove();
                                    //Update URL and store history for browser back/forward buttons
                                    history.pushState(null, null, mapNextPageUrl);
                                    //Find the new navigation and update, active state, next and prev buttons.
                                    var $mapNewPagination = $(mapResponse).find(mapPaginationClass);
                                    $(mapPaginationClass).replaceWith($mapNewPagination);
                                }

                                //Remove loading div and clear timer.
                                mapLoaded();

                            }
        });
    };


    /**
     * While new posts are loaded.
     * Show loader.gif.
     * Add loading text to button if condition is true.
     * This function is called using a setTimeout of 750 in the click event handler.
     */
    var mapLoading = function() {
        $('.malinky-ajax-paging-loading').show();
        if (mapPagingType == 'load-more' || mapPagingType == 'infinite-scroll') {
            $('.malinky-ajax-paging-button').text(mapLoadingMorePostsText);
        }        
    };


    /**
     * After new posts have been loaded.
     * Hide loader.gif.
     * Add loading text to button if condition is true.
     * Clear timer.
     */
    var mapLoaded = function() {        
        $('.malinky-ajax-paging-loading').hide();        
        if (mapPagingType == 'load-more' || mapPagingType == 'infinite-scroll') {
            $('.malinky-ajax-paging-button').text(mapLoadMoreButtonText);
        }
        clearTimeout(mapLoadingTimer);
    };


    /**
     * Infinite scroll ran through debounce function.
     */
    var mapInfiniteScroll = debounce(function() {
        mapContentPixelsToDocBottom = $(document).height() - $(window).scrollTop() - $(window).height();
        if (mapContentPixelsToDocBottom - mapInfiniteScrollBuffer < mapPaginationClassPixelsToDocBottom) {
            //Delay loading text and div.
            mapLoadingTimer = setTimeout(mapLoading, 750);
            //Load more posts.
            mapLoadPosts();
            /**
             * Debug timer. Remove mapLoadPosts call and use setTimeout instead.
             * setTimeout(mapLoadPosts, 3000);
             */       
        }
    }, 250);


    // Returns a function, that, as long as it continues to be invoked, will not
    // be triggered. The function will be called after it stops being called for
    // N milliseconds. If `immediate` is passed, trigger the function on the
    // leading edge, instead of the trailing.
    function debounce (func, wait, immediate) {
        var timeout;
        return function() {
            var context = this, args = arguments;
            var later = function() {
                timeout = null;
                if (!immediate) func.apply(context, args);
            };
            var callNow = immediate && !timeout;
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
            if (callNow) func.apply(context, args);
        };
    };


    //Start.
    init();

})(jQuery);